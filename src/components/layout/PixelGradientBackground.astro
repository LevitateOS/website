---
interface RGB {
	r: number
	g: number
	b: number
}

interface Stop {
	at: number
	color: RGB
}

interface Pixel {
	x: number
	y: number
	fill: string
}

const cols = 36
const rows = 24

function clamp01(value: number): number {
	return Math.min(1, Math.max(0, value))
}

function clamp255(value: number): number {
	return Math.min(255, Math.max(0, value))
}

function hexToRgb(hex: string): RGB {
	const clean = hex.replace("#", "")
	const expanded = clean.length === 3 ? clean.split("").map((char) => char + char).join("") : clean
	const value = Number.parseInt(expanded, 16)
	return {
		r: (value >> 16) & 255,
		g: (value >> 8) & 255,
		b: value & 255,
	}
}

function lerp(a: number, b: number, t: number): number {
	return a + (b - a) * t
}

function mix(a: RGB, b: RGB, t: number): RGB {
	return {
		r: lerp(a.r, b.r, t),
		g: lerp(a.g, b.g, t),
		b: lerp(a.b, b.b, t),
	}
}

function sampleGradient(stops: Stop[], t: number): RGB {
	const clamped = clamp01(t)
	for (let i = 0; i < stops.length - 1; i += 1) {
		const left = stops[i]
		const right = stops[i + 1]
		if (clamped >= left.at && clamped <= right.at) {
			const span = Math.max(0.0001, right.at - left.at)
			const local = (clamped - left.at) / span
			return mix(left.color, right.color, local)
		}
	}
	return stops[stops.length - 1]?.color ?? hexToRgb("#0b3cff")
}

function fract(value: number): number {
	return value - Math.floor(value)
}

function hashNoise(x: number, y: number): number {
	return fract(Math.sin(x * 127.1 + y * 311.7) * 43758.5453123)
}

function quantize(value: number, steps: number): number {
	const normalized = clamp01(value / 255)
	const quantized = Math.round(normalized * (steps - 1)) / (steps - 1)
	return quantized * 255
}

function toCssRgb(color: RGB): string {
	return `rgb(${Math.round(color.r)} ${Math.round(color.g)} ${Math.round(color.b)})`
}

function buildPixelLayer(
	stops: Stop[],
	opts: {
		levels: number
		noise: number
		lift: number
		warmth: number
		vignette: number
	}
): Pixel[] {
	const pixels: Pixel[] = []

	for (let y = 0; y < rows; y += 1) {
		for (let x = 0; x < cols; x += 1) {
			const nx = cols > 1 ? x / (cols - 1) : 0
			const ny = rows > 1 ? y / (rows - 1) : 0
			const sweep = clamp01(nx * 0.82 + ny * 0.18)
			const base = sampleGradient(stops, sweep)

			const blueGlow = clamp01(1 - Math.hypot(nx - 0.1, ny - 0.08) / 0.75)
			const magentaGlow = clamp01(1 - Math.hypot(nx - 0.88, ny - 0.14) / 0.72)
			const warmGlow = clamp01(1 - Math.hypot(nx - 0.55, ny - 0.92) / 0.88)

			const grain = (hashNoise(x, y) - 0.5) * opts.noise
			const checker = ((x + y) % 2 === 0 ? 1 : -1) * (opts.noise * 0.12)
			const edgeFalloff = (Math.hypot(nx - 0.5, ny - 0.5) / 0.85) * opts.vignette
			const topLift = opts.lift * (1 - ny * 0.55)

			let r = base.r + warmGlow * opts.warmth + magentaGlow * 12 - blueGlow * 8 + grain + checker + topLift - edgeFalloff
			let g = base.g + warmGlow * (opts.warmth * 0.45) + magentaGlow * 8 + blueGlow * 6 + grain * 0.9 + checker * 0.9 + topLift - edgeFalloff
			let b = base.b + blueGlow * 18 + magentaGlow * 10 - warmGlow * 6 + grain * 1.1 + checker + topLift - edgeFalloff

			r = quantize(clamp255(r), opts.levels)
			g = quantize(clamp255(g), opts.levels)
			b = quantize(clamp255(b), opts.levels)

			pixels.push({
				x,
				y,
				fill: toCssRgb({ r, g, b }),
			})
		}
	}

	return pixels
}

const lightStops: Stop[] = [
	{ at: 0, color: hexToRgb("#0b3cff") },
	{ at: 0.35, color: hexToRgb("#2e6bff") },
	{ at: 0.6, color: hexToRgb("#6b5cff") },
	{ at: 0.8, color: hexToRgb("#c14cff") },
	{ at: 1, color: hexToRgb("#ff8a3d") },
]

const darkStops: Stop[] = [
	{ at: 0, color: hexToRgb("#1f44ff") },
	{ at: 0.35, color: hexToRgb("#4f83ff") },
	{ at: 0.6, color: hexToRgb("#8a7cff") },
	{ at: 0.8, color: hexToRgb("#d06bff") },
	{ at: 1, color: hexToRgb("#ff9a57") },
]

const lightPixels = buildPixelLayer(lightStops, {
	levels: 15,
	noise: 16,
	lift: 10,
	warmth: 24,
	vignette: 18,
})

const darkPixels = buildPixelLayer(darkStops, {
	levels: 13,
	noise: 20,
	lift: 16,
	warmth: 32,
	vignette: 24,
})
---

<div id="site-background" class="site-background" aria-hidden="true">
	<div class="site-background__track">
		<svg
			class="site-background__pixels site-background__pixels--light"
			viewBox={`0 0 ${cols} ${rows}`}
			preserveAspectRatio="none"
			shape-rendering="crispEdges"
		>
			{lightPixels.map((pixel) => (
				<rect x={pixel.x} y={pixel.y} width="1" height="1" fill={pixel.fill} />
			))}
		</svg>

		<svg
			class="site-background__pixels site-background__pixels--dark"
			viewBox={`0 0 ${cols} ${rows}`}
			preserveAspectRatio="none"
			shape-rendering="crispEdges"
		>
			{darkPixels.map((pixel) => (
				<rect x={pixel.x} y={pixel.y} width="1" height="1" fill={pixel.fill} />
			))}
		</svg>

		<div class="site-background__veil" />
	</div>
</div>

<script>
	(() => {
		const background = document.getElementById("site-background")
		if (!background) return

		if (window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
			background.style.setProperty("--bg-parallax-shift", "0px")
			return
		}

		const maxShiftViewportRatio = 0.26
		let rafId = 0

		const updateParallax = () => {
			rafId = 0
			const scrollTop = window.scrollY || window.pageYOffset || 0
			const maxScrollable = Math.max(1, document.documentElement.scrollHeight - window.innerHeight)
			const progress = Math.min(1, Math.max(0, scrollTop / maxScrollable))
			const maxShiftPx = Math.round(window.innerHeight * maxShiftViewportRatio)
			const shift = Math.round(progress * maxShiftPx)
			background.style.setProperty("--bg-parallax-shift", `${shift}px`)
		}

		const queueUpdate = () => {
			if (rafId !== 0) return
			rafId = window.requestAnimationFrame(updateParallax)
		}

		updateParallax()
		window.addEventListener("scroll", queueUpdate, { passive: true })
		window.addEventListener("resize", queueUpdate, { passive: true })
	})()
</script>
