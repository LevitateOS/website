---
import type { RichText, InlineNode } from "@levitate/docs-content"

interface Props {
	content: string | RichText
}

const { content } = Astro.props

type InlinePart =
	| { type: "text"; content: string }
	| { type: "code"; content: string }
	| { type: "link"; content: string; href: string }
	| { type: "bold"; content: string }

function escapeHtml(value: string): string {
	return value
		.replaceAll("&", "&amp;")
		.replaceAll("<", "&lt;")
		.replaceAll(">", "&gt;")
		.replaceAll('"', "&quot;")
		.replaceAll("'", "&#39;")
}

function sanitizeHref(rawHref: string): string {
	const href = rawHref.trim()
	const lower = href.toLowerCase()
	if (
		lower.startsWith("/") ||
		lower.startsWith("#") ||
		lower.startsWith("http://") ||
		lower.startsWith("https://") ||
		lower.startsWith("mailto:") ||
		lower.startsWith("tel:")
	) {
		return escapeHtml(href)
	}
	return "#"
}

function parseInlineContent(text: string): InlinePart[] {
	const parts: InlinePart[] = []
	const regex = /`([^`]+)`|\[([^\]]+)\]\(((?:[^()]+|\([^()]*\))+\))|\*\*(.+?)\*\*/g
	let lastIndex = 0
	let match

	while ((match = regex.exec(text)) !== null) {
		if (match.index > lastIndex) {
			parts.push({ type: "text", content: text.slice(lastIndex, match.index) })
		}

		if (match[1]) {
			parts.push({ type: "code", content: match[1] })
		} else if (match[2] && match[3]) {
			parts.push({ type: "link", content: match[2], href: match[3] })
		} else if (match[4]) {
			parts.push({ type: "bold", content: match[4] })
		}

		lastIndex = match.index + match[0].length
	}

	if (lastIndex < text.length) {
		parts.push({ type: "text", content: text.slice(lastIndex) })
	}

	return parts.length > 0 ? parts : [{ type: "text", content: text }]
}

function renderInlineNode(node: InlineNode): string {
	if (typeof node === "string") {
		return escapeHtml(node)
	}
	switch (node.type) {
		case "link":
			return `<a href="${sanitizeHref(node.href)}" class="ui-link">${escapeHtml(node.text)}</a>`
		case "bold":
			return `<strong>${escapeHtml(node.text)}</strong>`
		case "code":
			return `<code class="code-plate px-1.5 py-0.5 font-mono text-[0.82em]">${escapeHtml(node.text)}</code>`
		case "italic":
			return `<em>${escapeHtml(node.text)}</em>`
		default:
			return ""
	}
}

function renderContent(content: string | RichText): string {
	if (Array.isArray(content)) {
		return content.map(renderInlineNode).join("")
	}

	const parts = parseInlineContent(content)
	return parts
		.map((part) => {
			if (part.type === "code") {
				return `<code class="code-plate px-1.5 py-0.5 font-mono text-[0.82em]">${escapeHtml(part.content)}</code>`
			}
			if (part.type === "link") {
				return `<a href="${sanitizeHref(part.href)}" class="ui-link">${escapeHtml(part.content)}</a>`
			}
			if (part.type === "bold") {
				return `<strong>${escapeHtml(part.content)}</strong>`
			}
			return escapeHtml(part.content)
		})
		.join("")
}

const renderedContent = renderContent(content)
---

<Fragment set:html={renderedContent} />
